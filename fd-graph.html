<!DOCTYPE html>
<meta charset="utf-8">

<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

.link {
  stroke: #999;
  stroke-opacity: .6;
}

text {
  font: 12px sans-serif;
  pointer-events: none;
}

text.shadow {
  stroke: #fff;
  stroke-width: 3px;
  stroke-opacity: .8;
}

</style>


<body>

  <div id="viz">
  </div>

  <div id="options">

      <input name="resetButton" 
                   type="button" 
                  value="Reset" 
                  onclick="reset()" />
  </div>

  <script src="d3.v3.min.js"></script>
  <script src="jquery-1.10.2.min.js"></script>

  <script>

  var width = 960,
      height = 700;

  var color = d3.scale.category20();

  var force = d3.layout.force()
      .charge(-220)
      .linkDistance(60)
      .size([width, height]);

  var svg = d3.select("#viz").append("svg")
      .attr("width", width)
      .attr("height", height);

  // The complete data...
  var orig_graph = null;
  var all_nodes = {};

  // The selected data, displayed in the graph
  var curr_links = null;
  var curr_nodes = null;

  // Derived data, including active groups
  var active_groups = {};
  var active_predicates = {};



  function init() {

    d3.json("jimmy.json", function(error, json_data) {

      // Store original graph data
      orig_graph = json_data;

      // Compute distinct nodes objects from the link source/target
      orig_graph.links.forEach(function(link) {
        console.log(link)
        link.source = all_nodes[link.source] || (all_nodes[link.source] = {name: link.source});
        link.target = all_nodes[link.target] || (all_nodes[link.target] = {name: link.target});
      });

      // Copy additional attributes from input JSON into derived node object
      orig_graph.nodes.forEach(function(node) {
        console.log(node)
        all_nodes[node.name]["group"] = node["group"];
      });

      // Deduce list of groups, and create group buttons
      $("#options").append("<br>")

      $.each(json_data.groups, function(index, group) {
        active_groups[group.id] = true;
        button_id = "group_selector_" + group.id;

        $("#options").append(
          "<input type='checkbox' checked id='"+button_id+"' value='"+group.id+"'>"
          +group.name
          )
        $("#"+button_id).change( function() {

          sel_grp = $(this).val();
          $(this).is(':checked') ? active_groups[sel_grp] = true : delete active_groups[sel_grp] ;

          // Refresh graph data, then update the vizualization
          filterData(active_groups, active_predicates);
          updateViz();

        });
      });

      $("#options").append("<br>")

      // Deduce list of predicates, create buttons
      $.each(json_data.predicates, function(index, predicate) {

        active_predicates[predicate.id] = true;

        $("#options").append(
          "<input type='checkbox' checked id='"+predicate.id+"' value='"+predicate.id+"'>"
          +predicate.name
          )
        $("#"+predicate.id).change( function() {

          sel_pred = $(this).val();
          $(this).is(':checked') ? active_predicates[sel_pred] = true : delete active_predicates[sel_pred] ;

          // Refresh graph data, then update the vizualization
          filterData(active_groups, active_predicates);
          updateViz();

        });
      });


      // Now initialize!
      filterData(active_groups, active_predicates);
      updateViz();

    });

  }



  function filterData(sel_groups, sel_predicates) {

    // Initialize the graph. 
    curr_nodes = [];
    curr_links = [];

    $.each(all_nodes, function(index, node) {

      if (node.group in sel_groups) {
        curr_nodes.push(node); 
      }

    });

    $.each(orig_graph.links, function(index, link) {

      if (link.source.group in sel_groups && 
          link.target.group in sel_groups &&
          link.pred in sel_predicates) {
        curr_links.push(link); 
      }

    });
  }



  function updateViz() {

    $('.node').remove();
    $('.link').remove();
    $('.shadow').remove();
    $('.label').remove();

    // Use the force
    force
        .nodes(curr_nodes)
        .links(curr_links)
        .start(); 

    // Create line selection from links, then initialize
    var lines = svg.selectAll(".lines")
        .data( curr_links );

    lines.enter()
        .append("line")
        .attr("class", "link")
        .style("stroke-width", function(d) { return Math.sqrt(d.value); });

    var edgepaths = svg.selectAll(".edgepath")
          .data(curr_links)
          .enter()
          .append('path')
          .attr({'d': function(d) {return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},
                 'class':'edgepath',
                 'fill-opacity':0,
                 'stroke-opacity':0,
                 'fill':'blue',
                 'stroke':'red',
                 'id':function(d,i) {return 'edgepath'+i}})
          .style("pointer-events", "none");

    // Edge labels and paths - cut and paste coding from:
    // http://bl.ocks.org/jhb/5955887
    var edgelabels = svg.selectAll(".edgelabel")
        .data(curr_links);

    edgelabels.enter()
        .append('text')
        .style("pointer-events", "none")
        .style("visibility", "hidden")
        .attr({'class':'edgelabel',
               'id':function(d,i){return 'edgelabel'+i},
               'dx':20,
               'dy':0,
               'font-size':10,
               'fill':'#aaa'});

    edgelabels.append('textPath')
          .attr('xlink:href',function(d,i) {return '#edgepath'+i})
          .style("pointer-events", "none")
          .text(function(d,i){return d.pred});

    // Create circle elements, initialize via enter
    var circles = svg.selectAll(".circles")
        .data( curr_nodes );

    circles.enter()
        .append("circle")
        .attr("class", "node")
        .attr("r", 10)
        .style("fill", function(d) { return color(d.group); })
        .call(force.drag);

    $(".node").hover( 
      function() { edgelabels.style("visibility", "visible") },
      function() { edgelabels.style("visibility", "hidden") });

    // Create one SVG group per node element, for labels
    var labels = svg.append("svg:g").selectAll(".labels")
        .data( curr_nodes )
        .enter().append("svg:g");

    labels.append("svg:text")
        .attr("x", 8)
        .attr("y", ".31em")
        .attr("class", "shadow")
        .text(function(d) { return d.name; });

    labels.append("svg:text")
        .attr("x", 8)
        .attr("y", ".31em")
        .attr("class", "label")
        .text(function(d) { return d.name; });

    // Define how SVG elements react to force tick events
    force.on("tick", function() {

      lines.attr("x1", function(d) { return d.source.x; })
          .attr("y1", function(d) { return d.source.y; })
          .attr("x2", function(d) { return d.target.x; })
          .attr("y2", function(d) { return d.target.y; });

      circles.attr("cx", function(d) { return d.x; })
          .attr("cy", function(d) { return d.y; });

      labels.attr("transform", function(d) {
          return "translate(" + d.x + "," + d.y + ")";
      });

      // Edge labels and paths - C&P from online sample
      edgepaths.attr('d', function(d) { 
          var path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;
          return path}); 

      edgelabels.attr('transform',function(d,i) {
          if (d.target.x<d.source.x){
            bbox = this.getBBox();
            rx = bbox.x+bbox.width/2;
            ry = bbox.y+bbox.height/2;
            return 'rotate(180 '+rx+' '+ry+')';
          }
          else {
            return 'rotate(0)';
          }
      });

    });

  };


  function reset() {

    curr_nodes = d3.values(all_nodes);
    curr_links = orig_graph.links;
    updateViz( );

  }


  init();

  /*  var tooltip = d3.select("body")
        .append("div")
        .style("position", "absolute")
        .style("z-index", "10")
        .style("visibility", "hidden")
        .text("a simple tooltip");

    node
      .on("mouseover", function(d) { 
          return tooltip.style("visibility", "visible").text(d.name);
        })
      .on("mousemove", function() {return tooltip.style("top", (event.pageY-10)+"px").style("left",(event.pageX+10)+"px");})
      .on("mouseout", function()  {return tooltip.style("visibility", "hidden");});
  */


  </script>

</body>
